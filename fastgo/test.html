<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Chunk Upload Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
</head>

<body>
    <h1>åˆ†ç‰‡ä¸Šä¼ æµ‹è¯•é¡µé¢</h1>
    <p style="color: #666; margin-bottom: 20px;">è¿™æ˜¯ç”¨äºæµ‹è¯•åˆ†ç‰‡ä¸Šä¼ åŠŸèƒ½çš„ç®€æ˜“ç‰ˆæœ¬ï¼Œä½¿ç”¨å‰è¯·å…ˆåˆ›å»ºä¸Šä¼ tokenå¹¶éªŒè¯ã€‚</p>
    
    <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
        <div style="margin-bottom: 10px;">
            <label for="tokenInput"><strong>Upload Token:</strong></label>
            <input type="text" id="tokenInput" value="" placeholder="è¾“å…¥ä¸Šä¼ token" style="width: 300px; padding: 5px; margin-left: 10px;" />
            <button id="validateTokenBtn" style="margin-left: 10px; padding: 5px 10px;">éªŒè¯Token</button>
        </div>
        <div id="tokenInfo" style="margin-top: 10px; padding: 8px; background-color: #fff; border: 1px solid #ccc; border-radius: 3px; display: none;">
            <div id="tokenStatus"></div>
        </div>
    </div>
    <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
        <h3 style="margin-top: 0;">æ–‡ä»¶é€‰æ‹©</h3>
        <div style="margin-bottom: 10px;">
            <label><strong>é€‰æ‹©å•ä¸ªæ–‡ä»¶:</strong></label>
            <input type="file" id="singleFileInput" style="margin-left: 10px;" />
        </div>
        <div style="margin-bottom: 10px;">
            <label><strong>é€‰æ‹©æ–‡ä»¶å¤¹:</strong></label>
            <input type="file" id="folderInput" webkitdirectory directory multiple style="margin-left: 10px;" />
        </div>
        <div>
            <button id="uploadBtn" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">å¼€å§‹ä¸Šä¼ </button>
            <button id="clearStorageBtn" style="padding: 8px 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">æ¸…ç©ºåç«¯å­˜å‚¨</button>
            <button id="listFilesBtn" style="padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">æŸ¥çœ‹æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨</button>
        </div>
    </div>
    <progress id="progressBar" value="0" max="100" style="width: 100%; height: 20px; margin-bottom: 10px;"></progress>
    <p id="status" style="margin-bottom: 20px; padding: 5px; background-color: #f5f5f5; border-radius: 3px; min-height: 20px;"></p>
    
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <div style="flex: 1;">
            <h4>å·²ç»ä¸Šä¼ å†…å®¹</h4>
            <div id="serverFilesList" 
                style="border:1px solid #ccc; padding:10px; max-height:300px; overflow:auto; background-color: #f9f9f9;">
                <p style="color: #666;"></p>
            </div>
        </div>
        <div style="flex: 1;">
            <h4>æœ¬æ¬¡ä¸Šä¼ å†…å®¹</h4>
            <div id="uploadStatusContainer"
                style="border:1px solid #ccc; padding:10px; max-height:300px; overflow:auto; background-color: #fff8dc;">
                <p style="color: #666;"></p>
            </div>
        </div>
    </div>
    
    <script>
        // éªŒè¯TokenåŠŸèƒ½
        document.getElementById('validateTokenBtn').onclick = async () => {
            const token = getToken();
            if (!token) {
                alert('è¯·è¾“å…¥Token');
                return;
            }
            
            try {
                const res = await fetch(`${BASE_URL}/api/token_info/${token}`);
                const tokenInfo = await res.json();
                const container = document.getElementById('tokenInfo');
                const statusDiv = document.getElementById('tokenStatus');
                
                if (tokenInfo.valid) {
                    if (tokenInfo.token_type !== 'upload') {
                        statusDiv.innerHTML = `<strong style="color: red;">âŒ é”™è¯¯ï¼šè¿™ä¸æ˜¯ä¸Šä¼ token (ç±»å‹: ${tokenInfo.token_type})</strong>`;
                        container.style.display = 'block';
                        return;
                    }
                    
                    const usedMB = Math.round((tokenInfo.used_bytes || 0) / 1024 / 1024);
                    const maxMB = Math.round((tokenInfo.max_storage_bytes || 0) / 1024 / 1024);
                    const remainingMB = maxMB - usedMB;
                    
                    statusDiv.innerHTML = `
                        <strong style="color: green;">âœ… Tokenæœ‰æ•ˆ</strong><br>
                        <strong>ç›®å½•:</strong> ${tokenInfo.directory_name || 'æœªçŸ¥'}<br>
                        <strong>å­˜å‚¨:</strong> ${usedMB}MB / ${maxMB}MB å·²ä½¿ç”¨ (å‰©ä½™ ${remainingMB}MB)<br>
                        <strong>è¿‡æœŸ:</strong> ${tokenInfo.expired ? 'å·²è¿‡æœŸ' : 'æœªè¿‡æœŸ'}<br>
                        <strong>æ¨¡æ¿:</strong> ${tokenInfo.template_style}
                    `;
                    container.style.display = 'block';
                    
                    // è‡ªåŠ¨åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                    document.getElementById('listFilesBtn').click();
                } else {
                    statusDiv.innerHTML = '<strong style="color: red;">âŒ Tokenæ— æ•ˆ</strong>';
                    container.style.display = 'block';
                }
            } catch (e) {
                document.getElementById('tokenStatus').innerHTML = `<strong style="color: red;">âŒ éªŒè¯å¤±è´¥: ${e.message}</strong>`;
                document.getElementById('tokenInfo').style.display = 'block';
            }
        };

        document.getElementById('listFilesBtn').onclick = async () => {
            const token = getToken();
            if (!token) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„Token');
                return;
            }
            
            // éªŒè¯tokenç±»å‹
            try {
                const tokenRes = await fetch(`${BASE_URL}/api/token_info/${token}`);
                const tokenInfo = await tokenRes.json();
                if (!tokenInfo.valid || tokenInfo.token_type !== 'upload') {
                    setStatus('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸Šä¼ token');
                    return;
                }
            } catch (e) {
                setStatus(`âŒ TokenéªŒè¯å¤±è´¥: ${e.message}`);
                return;
            }
            
            try {
                const res = await fetch(`${BASE_URL}/api/list_files/${token}`);
                const data = await res.json();
                const backendFiles = data.files;
                
                const container = document.getElementById('serverFilesList');
                container.innerHTML = '';
                
                if (backendFiles.length === 0) {
                    container.innerHTML = '<p style="color: #666;">æš‚æ— æ–‡ä»¶</p>';
                } else {
                    const ul = document.createElement('ul');
                    backendFiles.forEach(file => {
                        const li = document.createElement('li');
                        li.innerHTML = `ğŸ“„ <span style="font-family: monospace;">${file}</span>`;
                        ul.appendChild(li);
                    });
                    container.appendChild(ul);
                }
            } catch (e) {
                setStatus(`âŒ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ${e.message}`);
            }
        };
    </script>
    <script>
        const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB
        const MAX_CONCURRENT = 3;
        const MAX_RETRY = 3;
        const TIMEOUT = 30_000; // 30s
        const BASE_URL = 'http://127.0.0.1:54647';
        let controller = null; // ç”¨äºå–æ¶ˆä¸Šä¼ 

        function getToken() {
            return document.getElementById('tokenInput').value.trim();
        }

        document.getElementById('clearStorageBtn').onclick = async () => {
            const token = getToken();
            if (!token) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„Token');
                return;
            }
            
            // éªŒè¯tokenç±»å‹
            try {
                const tokenRes = await fetch(`${BASE_URL}/api/token_info/${token}`);
                const tokenInfo = await tokenRes.json();
                if (!tokenInfo.valid || tokenInfo.token_type !== 'upload') {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸Šä¼ token');
                    return;
                }
            } catch (e) {
                alert(`TokenéªŒè¯å¤±è´¥: ${e.message}`);
                return;
            }
            
            if (!confirm("ç¡®å®šè¦æ¸…ç©ºåç«¯å­˜å‚¨å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚")) return;
            try {
                const res = await fetch(`${BASE_URL}/api/clear_storage/${token}`, { method: 'DELETE' });
                const data = await res.json();
                if (data.cleared) {
                    setStatus("ğŸ§¹ åç«¯å­˜å‚¨å·²æ¸…ç©º");
                    // åˆ·æ–°æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨
                    const serverContainer = document.getElementById('serverFilesList');
                    serverContainer.innerHTML = '<p style="color: #666;">æš‚æ— æ–‡ä»¶</p>';
                    // æ¸…ç©ºä¸Šä¼ çŠ¶æ€å¯¹æ¯”
                    const statusContainer = document.getElementById('uploadStatusContainer');
                    statusContainer.innerHTML = '<p style="color: #666;"></p>';
                } else {
                    setStatus("âš ï¸ æ¸…ç©ºå¤±è´¥");
                }
            } catch (e) {
                setStatus(`âŒ æ¸…ç©ºå¤±è´¥: ${e.message}`);
            }
        };

        document.getElementById('uploadBtn').onclick = async () => {
            const token = getToken();
            if (!token) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„Token');
                return;
            }
            
            // éªŒè¯tokenç±»å‹
            try {
                const tokenRes = await fetch(`${BASE_URL}/api/token_info/${token}`);
                const tokenInfo = await tokenRes.json();
                if (!tokenInfo.valid) {
                    alert('Tokenæ— æ•ˆ');
                    return;
                }
                if (tokenInfo.token_type !== 'upload') {
                    alert(`é”™è¯¯ï¼šè¿™ä¸æ˜¯ä¸Šä¼ tokenï¼Œå½“å‰ç±»å‹: ${tokenInfo.token_type}`);
                    return;
                }
                if (tokenInfo.expired) {
                    alert('Tokenå·²è¿‡æœŸ');
                    return;
                }
            } catch (e) {
                alert(`TokenéªŒè¯å¤±è´¥: ${e.message}`);
                return;
            }
            
            const fileInput = document.getElementById('singleFileInput');
            const folderInput = document.getElementById('folderInput');

            const singleFile = fileInput.files[0];
            const folderFiles = Array.from(folderInput.files); // å¯èƒ½ä¸º []

            let files = [];

            if (singleFile) {
                // æ„é€ ä¸€ä¸ªæ¨¡æ‹Ÿ folderInput çš„ç»“æ„ï¼Œä¾¿äºç»Ÿä¸€å¤„ç†
                singleFile.relativePath = singleFile.name;
                files = [singleFile];
            } else if (folderFiles.length > 0) {
                // æ¯ä¸ª folderFile éƒ½åŒ…å« webkitRelativePath
                files = folderFiles;
            } else {
                alert("è¯·å…ˆé€‰æ‹©æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹");
                return;
            }

            controller = new AbortController();
            
            // è®°å½•ä¸Šä¼ å‰çš„æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨
            let previousFiles = [];
            try {
                const res = await fetch(`${BASE_URL}/api/list_files/${token}`);
                const data = await res.json();
                previousFiles = data.files || [];
            } catch (e) {
                console.log('æ— æ³•è·å–ä¸Šä¼ å‰çš„æ–‡ä»¶åˆ—è¡¨');
            }

            try {
                const uploadedFiles = [];
                for (const file of files) {
                    const relativePath = file.webkitRelativePath || file.relativePath;
                    const success = await handleUpload(file, relativePath);
                    if (success !== false) { // ä¸Šä¼ æˆåŠŸæˆ–ç§’ä¼ 
                        uploadedFiles.push(relativePath);
                    }
                    await showDiffTree(files);
                }
                
                // ä¸Šä¼ å®Œæˆåç«‹å³åˆ·æ–°æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨ï¼Œå¹¶æ ‡è¯†æ–°ä¸Šä¼ çš„æ–‡ä»¶
                await refreshServerFilesList(uploadedFiles, previousFiles);
                setStatus('âœ… æ‰€æœ‰ä¸Šä¼ å®Œæˆ');
            } catch (err) {
                setStatus(`âŒ ä¸Šä¼ å¤±è´¥: ${err.message}`);
            } finally {
                // æ¸…ç©º input ä»¥ä¾¿ç”¨æˆ·èƒ½é‡æ–°é€‰æ‹©æ–‡ä»¶
                fileInput.value = '';
                folderInput.value = '';
            }
        };

        function buildDiffTree(localFiles, backendFiles) {
            const backendSet = new Set(backendFiles);
            const root = {};

            for (const path of localFiles) {
                const parts = path.split('/');
                let current = root;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (!current[part]) {
                        current[part] = {
                            __children: {},
                            __status: (i === parts.length - 1)
                                ? (backendSet.has(path) ? 'uploaded' : 'missing')
                                : null
                        };
                    }
                    current = current[part].__children;
                }
            }

            return root;
        }
        // é€’å½’æ¸²æŸ“æ ‘ä¸º <ul><li>
        function renderTree(tree, container) {
            const ul = document.createElement('ul');
            for (const key in tree) {
                const li = document.createElement('li');
                const node = tree[key];

                const isFile = node.__status !== null;
                if (isFile) {
                    const statusIcon = node.__status === 'uploaded' ? 'ğŸ˜Š' : 'âŒ';
                    li.textContent = `${statusIcon} ${key}`;
                } else {
                    const statusIcon = node.__status = 'ğŸ˜Š';
                    li.textContent = `${statusIcon} ${key}`;
                    renderTree(node.__children, li);
                }

                ul.appendChild(li);
            }
            container.appendChild(ul);
        }

        async function showDiffTree(localFiles) {
            setStatus("ğŸ” æ¯”è¾ƒæœ¬åœ°ä¸æœåŠ¡å™¨æ–‡ä»¶...");
            const token = getToken();
            if (!token) {
                setStatus("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„Token");
                return;
            }

            const res = await fetch(`${BASE_URL}/api/list_files/${token}`);
            const data = await res.json();
            const backendFiles = data.files;

            const relativePaths = localFiles.map(f => f.webkitRelativePath || f.relativePath);
            const diffTree = buildDiffTree(relativePaths, backendFiles);

            const container = document.getElementById('uploadStatusContainer');
            container.innerHTML = '';
            renderTree(diffTree, container);
        }

        function setProgress(percent) {
            document.getElementById('progressBar').value = percent;
        }

        function setStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function createFileChunks(file, chunkSize = CHUNK_SIZE) {
            const chunks = [];
            let cur = 0;
            while (cur < file.size) {
                chunks.push({
                    index: chunks.length,
                    chunk: file.slice(cur, cur + chunkSize)
                });
                cur += chunkSize;
            }
            return chunks;
        }

        async function calculateHash(chunks) {
            const spark = new SparkMD5.ArrayBuffer();
            // for (let i = 0; i < chunks.length; i++) {
            //     const chunk = await chunks[i].chunk.arrayBuffer();
            //     spark.append(chunk);
            // }
            const firstChunk = await chunks[0].chunk.arrayBuffer();
            const lastChunk = await chunks[chunks.length - 1].chunk.arrayBuffer();

            spark.append(firstChunk);
            spark.append(lastChunk);
            return spark.end();
        }

        async function checkUploadedChunks(hash) {
            const token = getToken();
            const res = await fetch(`${BASE_URL}/api/check_upload/${token}?hash=${hash}`);
            const data = await res.json();
            return new Set(data.uploaded || []);
        }

        async function uploadChunkWithRetry(chunk, hash, relativePath) {
            let attempt = 0;
            while (attempt < MAX_RETRY) {
                try {
                    const token = getToken();
                    const formData = new FormData();
                    formData.append('file', chunk.chunk);
                    formData.append('index', chunk.index);
                    formData.append('hash', hash);
                    formData.append('relativePath', relativePath);

                    const controllerTimeout = new AbortController();
                    const timeout = setTimeout(() => controllerTimeout.abort(), TIMEOUT);

                    await fetch(`${BASE_URL}/api/upload_chunk/${token}`, {
                        method: 'POST',
                        body: formData,
                        signal: controllerTimeout.signal,
                    });

                    clearTimeout(timeout);
                    return;
                } catch (e) {
                    attempt++;
                    if (attempt >= MAX_RETRY) throw new Error(`åˆ†ç‰‡ ${chunk.index} ä¸Šä¼ å¤±è´¥`);
                }
            }
        }

        async function uploadChunks(chunks, hash, uploadedSet, onProgress, relativePath) {
            let uploaded = 0;

            const limit = asyncPool(MAX_CONCURRENT, chunks, async (chunk) => {
                if (uploadedSet.has(chunk.index)) {
                    uploaded++;
                    onProgress(uploaded / chunks.length);
                    return;
                }

                await uploadChunkWithRetry(chunk, hash, relativePath);
                uploaded++;
                onProgress(uploaded / chunks.length);
            });

            await limit;
        }

        async function mergeChunks(hash, totalChunks, relativePath) {
            const token = getToken();
            const res = await fetch(`${BASE_URL}/api/merge_chunks/${token}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ hash, totalChunks, relativePath })
            });

            if (!res.ok) {
                const err = await res.json();
                throw new Error(err.detail || `åˆå¹¶å¤±è´¥ï¼ŒçŠ¶æ€ç  ${res.status}`);
            }

            return await res.json(); // merged info
        }

        async function handleUpload(file, relativePath) {
            setStatus(`â³ å¤„ç† ${relativePath}`);
            const chunks = createFileChunks(file);
            const hash = await calculateHash(chunks);
            const token = getToken();

            const checkRes = await fetch(`${BASE_URL}/api/check_file/${token}?relativePath=${encodeURIComponent(relativePath)}`);
            const checkData = await checkRes.json();
            if (checkData.complete === true) {
                setStatus(`âš¡ ç§’ä¼ æˆåŠŸï¼š${relativePath}`);
                return true; // ç§’ä¼ æˆåŠŸ
            }

            // â±ï¸ å¼€å§‹è®¡æ—¶
            const startTime = performance.now();
            const uploadedSet = await checkUploadedChunks(hash);
            await uploadChunks(chunks, hash, uploadedSet, (p) => {
                setProgress(p * 100);
            }, relativePath);

            // â±ï¸ ç»“æŸè®¡æ—¶
            const endTime = performance.now();
            const timeInSeconds = ((endTime - startTime) / 1000).toFixed(2);

            console.log(`ğŸ“¦ ä¸Šä¼ è€—æ—¶ï¼š${timeInSeconds} ç§’`);
            try {
                const result = await mergeChunks(hash, chunks.length, relativePath);
                setStatus(`âœ… ä¸Šä¼ å¹¶åˆå¹¶å®Œæˆï¼š${relativePath}`);
                return true; // ä¸Šä¼ æˆåŠŸ
            } catch (e) {
                setStatus(`âŒ åˆå¹¶å¤±è´¥ï¼š${e.message}`);
                return false; // ä¸Šä¼ å¤±è´¥
            }
        }

        // åˆ·æ–°æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨å¹¶æ ‡è¯†æ–°ä¸Šä¼ çš„æ–‡ä»¶
        async function refreshServerFilesList(newlyUploadedFiles, previousFiles) {
            const token = getToken();
            try {
                const res = await fetch(`${BASE_URL}/api/list_files/${token}`);
                const data = await res.json();
                const currentFiles = data.files || [];
                
                const container = document.getElementById('serverFilesList');
                container.innerHTML = '';
                
                if (currentFiles.length === 0) {
                    container.innerHTML = '<p style="color: #666;">æš‚æ— æ–‡ä»¶</p>';
                } else {
                    const ul = document.createElement('ul');
                    const newlyUploadedSet = new Set(newlyUploadedFiles);
                    const previousSet = new Set(previousFiles);
                    
                    currentFiles.forEach(file => {
                        const li = document.createElement('li');
                        let icon = 'ğŸ“„'; // é»˜è®¤æ–‡ä»¶å›¾æ ‡
                        let style = '';
                        
                        if (newlyUploadedSet.has(file)) {
                            // æœ¬æ¬¡æ–°ä¸Šä¼ çš„æ–‡ä»¶
                            icon = 'ğŸ†•';
                            style = 'color: #28a745; font-weight: bold;';
                        } else if (previousSet.has(file)) {
                            // ä¹‹å‰å·²ç»å­˜åœ¨çš„æ–‡ä»¶
                            icon = 'ğŸ“„';
                            style = 'color: #6c757d;';
                        } else {
                            // å…¶ä»–æ—¶å€™ä¸Šä¼ çš„æ–‡ä»¶ï¼ˆä¸åœ¨æœ¬æ¬¡ä¸Šä¼ åˆ—è¡¨ä¸­ï¼‰
                            icon = 'ğŸ“';
                            style = 'color: #17a2b8;';
                        }
                        
                        li.innerHTML = `${icon} <span style="font-family: monospace; ${style}">${file}</span>`;
                        ul.appendChild(li);
                    });
                    container.appendChild(ul);
                }
            } catch (e) {
                console.error('åˆ·æ–°æœåŠ¡å™¨æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', e);
                const container = document.getElementById('serverFilesList');
                container.innerHTML = '<p style="color: #dc3545;">âŒ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥</p>';
            }
        }

        // æ§åˆ¶å¹¶å‘ï¼ˆæ‰‹åŠ¨å®ç° async poolï¼‰
        async function asyncPool(limit, array, iteratorFn) {
            const ret = [];
            const executing = [];

            for (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                ret.push(p);

                if (limit <= array.length) {
                    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                    executing.push(e);
                    if (executing.length >= limit) {
                        await Promise.race(executing);
                    }
                }
            }

            return Promise.all(ret);
        }
    </script>
    <style>
        ul {
            list-style-type: none;
            padding-left: 1em;
            /* æ§åˆ¶ç¼©è¿›ï¼Œä¿ç•™æ ‘ç»“æ„å±‚çº§æ„Ÿ */
            margin: 0;
        }

        li {
            margin: 2px 0;
        }
    </style>
</body>

</html>